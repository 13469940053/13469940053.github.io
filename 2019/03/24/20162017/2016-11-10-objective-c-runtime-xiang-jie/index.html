<!DOCTYPE HTML>
<html lang="zh-CN">


<head><meta name="generator" content="Hexo 3.8.0">
    <meta charset="utf-8">
    <meta name="keywords" content="无浪网、张成的博客、无风不起浪网、无浪博客">
    <meta name="description" content="
layout:     posttitle:      Objective-C Runtime 详解subtitle:   Runtime 详解date:       2017-02-04author:     BYheader-img:">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>张成的博客</title>
    <link rel="icon" type="image/png" href="/favicon.png">

    <link rel="stylesheet" type="text/css" href="/libs/awesome/css/font-awesome.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/materialize/materialize.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/aos/aos.css">
    <link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css">
    <link rel="stylesheet" type="text/css" href="/css/matery.css">
    <link rel="stylesheet" type="text/css" href="/css/my.css">
    <style type="text/css">
        
    </style>

    <script src="/libs/jquery/jquery-2.2.0.min.js"></script>
</head>


<body>

<header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="/medias/logo.png" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">张成的博客</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fa fa-navicon"></i></a>
<ul class="right">
    
    <li class="hide-on-med-and-down">
        <a href="/" class="waves-effect waves-light">
            
            <i class="fa fa-home"></i>
            
            <span>首页</span>
        </a>
    </li>
    
    <li class="hide-on-med-and-down">
        <a href="/tags" class="waves-effect waves-light">
            
            <i class="fa fa-tags"></i>
            
            <span>标签</span>
        </a>
    </li>
    
    <li class="hide-on-med-and-down">
        <a href="/categories" class="waves-effect waves-light">
            
            <i class="fa fa-bookmark"></i>
            
            <span>分类</span>
        </a>
    </li>
    
    <li class="hide-on-med-and-down">
        <a href="/archives" class="waves-effect waves-light">
            
            <i class="fa fa-archive"></i>
            
            <span>总览</span>
        </a>
    </li>
    
    <li class="hide-on-med-and-down">
        <a href="/about" class="waves-effect waves-light">
            
            <i class="fa fa-user-circle-o"></i>
            
            <span>关于我</span>
        </a>
    </li>
    
    <li class="hide-on-med-and-down">
        <a href="/friends" class="waves-effect waves-light">
            
            <i class="fa fa-address-book"></i>
            
            <span>网络课堂</span>
        </a>
    </li>
    
    <li class="hide-on-med-and-down">
        <a href="/webcode" class="waves-effect waves-light">
            
            <i class="fa fa-user-md"></i>
            
            <span>资料总览</span>
        </a>
    </li>
    
    <li>
        <a href="#searchModal" class="modal-trigger waves-effect waves-light">
            <i id="searchIcon" class="fa fa-search" title="搜索"></i>
        </a>
    </li>
</ul>

<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="/medias/logo.png" class="logo-img circle responsive-img">
        
        <div class="logo-name">张成的博客</div>
        <div class="logo-desc">
            
            无浪网、张成的博客、无浪博客、无风不起浪网由张成初期学习前端知识所做，仅供学习和资料储存使用！张成留言
            
        </div>
    </div>

    

    <ul class="menu-list mobile-menu-list">
        
        <li>
            <a href="/" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-home"></i>
                
                首页
            </a>
        </li>
        
        <li>
            <a href="/tags" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-tags"></i>
                
                标签
            </a>
        </li>
        
        <li>
            <a href="/categories" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-bookmark"></i>
                
                分类
            </a>
        </li>
        
        <li>
            <a href="/archives" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-archive"></i>
                
                总览
            </a>
        </li>
        
        <li>
            <a href="/about" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-user-circle-o"></i>
                
                关于我
            </a>
        </li>
        
        <li>
            <a href="/friends" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-address-book"></i>
                
                网络课堂
            </a>
        </li>
        
        <li>
            <a href="/webcode" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-user-md"></i>
                
                资料总览
            </a>
        </li>
        
        
    </ul>
</div>

        </div>

        
    </nav>

</header>


<script src="/libs/cryptojs/crypto-js.min.js"></script>
<script>
    (function() {
        let pwd = '';
        if (pwd && pwd.length > 0) {
            if (pwd !== CryptoJS.SHA256(prompt('请输入访问本文章的密码')).toString(CryptoJS.enc.Hex)) {
                alert('密码错误，将返回主页！');
                location.href = '/';
            }
        }
    })();
</script>




<div class="bg-cover pd-header post-cover" style="background-image: url('/medias/featureimages/0.jpg')">
    <div class="container">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <div class="description center-align post-title">
                        
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>



<main class="post-container content">

    
    <link rel="stylesheet" href="/libs/tocbot/tocbot.css">
<style>
    #articleContent h1::before,
    #articleContent h2::before,
    #articleContent h3::before,
    #articleContent h4::before,
    #articleContent h5::before,
    #articleContent h6::before {
        display: block;
        content: " ";
        height: 100px;
        margin-top: -100px;
        visibility: hidden;
    }

    #articleContent :focus {
        outline: none;
    }

    .toc-fixed {
        position: fixed;
        top: 64px;
    }

    .toc-widget {
        padding-left: 20px;
    }

    .toc-widget .toc-title {
        margin: 35px 0 15px 0;
        padding-left: 17px;
        font-size: 1.5rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    .toc-widget ol {
        padding: 0;
        list-style: none;
    }

    #toc-content ol {
        padding-left: 10px;
    }

    #toc-content ol li {
        padding-left: 10px;
    }

    #toc-content .toc-link:hover {
        color: #42b983;
        font-weight: 700;
        text-decoration: underline;
    }

    #toc-content .toc-link::before {
        background-color: transparent;
        max-height: 25px;
    }

    #toc-content .is-active-link {
        color: #42b983;
    }

    #toc-content .is-active-link::before {
        background-color: #42b983;
    }

    #floating-toc-btn {
        position: fixed;
        right: 20px;
        bottom: 76px;
        padding-top: 15px;
        margin-bottom: 0;
        z-index: 998;
    }

    #floating-toc-btn .btn-floating {
        width: 48px;
        height: 48px;
    }

    #floating-toc-btn .btn-floating i {
        line-height: 48px;
        font-size: 1.4rem;
    }
</style>
<div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                          <div class="article-tag">
                            <span class="chip bg-color">无标签</span>
                          </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                </div>
            </div>

            <div class="post-info">
                <div class="post-date info-break-policy">
                    <i class="fa fa-calendar-minus-o fa-fw"></i>发布日期:&nbsp;&nbsp;
                    2019-03-24
                </div>

                
                    
                    <div class="info-break-policy">
                        <i class="fa fa-file-word-o fa-fw"></i>文章字数:&nbsp;&nbsp;
                        9.4k
                    </div>
                    

                    
                    <div class="info-break-policy">
                        <i class="fa fa-clock-o fa-fw"></i>阅读时长:&nbsp;&nbsp;
                        36 分
                    </div>
                    
                
				
				
                    <div id="busuanzi_container_page_pv" class="info-break-policy">
                        <i class="fa fa-eye fa-fw"></i>阅读次数:&nbsp;&nbsp;
                        <span id="busuanzi_value_page_pv"></span>
                    </div>
				
            </div>
        </div>
        <hr class="clearfix">
        <div class="card-content article-card-content">
            <div id="articleContent">
                <hr>
<p>layout:     post<br>title:      Objective-C Runtime 详解<br>subtitle:   Runtime 详解<br>date:       2017-02-04<br>author:     BY<br>header-img: img/post-bg-ios9-web.jpg<br>catalog: true<br>tags:</p>
<pre><code>- Obj-C
- Runtime
- iOS
</code></pre><hr>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote>
<p>最近在学习Runtime的知识，恰巧发现了这篇博客<a href="http://yulingtianxia.com/blog/2014/11/05/objective-c-runtime/" target="_blank" rel="noopener">《Objective-C Runtime》</a>，在此基础上，进行了些许补充说明,如有错误或其他想法，欢迎提出交流。</p>
</blockquote>
<h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><ul>
<li>引言</li>
<li>简介</li>
<li>与Runtime交互</li>
<li>RunTime术语</li>
<li>消息</li>
<li>动态方法解析</li>
<li>消息转发</li>
<li>健壮的实例变量</li>
<li>动态添加属性(Object-C Associated Objects)</li>
<li>方法调剂（Method Swizzling）</li>
<li>总结</li>
</ul>
<h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>Objective-C的方法调用实则为“发送消息”,我们来看<code>[dog eat]</code>实际会被编译器转化为</p>
<pre><code>objc_msgSend(dog, SEL)//SEL为eat方法的标识符@selector(@&quot;eat&quot;)
</code></pre><p>若方法中函数参数，则为：</p>
<pre><code>objc_msgSend(dog, SEL, arg1, arg2, ...)
</code></pre><p>如果消息的接收者能够找到对应的方法，那么就相当于直接执行了接收者这个对象的特定方法；否则，消息要么被转发，或是临时向接收者动态添加这个方法对应的实现内容，要么就干脆就crash掉。</p>
<p>现在可以看出<code>[dog eat]</code>真的不是一个简简单单的方法调用。因为这只是在编译阶段确定了要向接收者发送<code>eat</code>这条消息，而<code>dog</code>将要如何响应这条消息，那就要看运行时发生的情况来决定了。</p>
<p>Objective-C 的 Runtime 铸就了它动态语言的特性，这些深层次的知识虽然平时写代码用的少一些，但是却是每个 Objc 程序员需要了解的。</p>
<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>因为Objc是一门动态语言，所以它总是想办法把一些决定工作从编译连接推迟到运行时。也就是说只有编译器是不够的，还需要一个运行时系统 (runtime system) 来执行编译后的代码。这就是 Objective-C Runtime 系统存在的意义，它是整个Objc运行框架的一块基石。</p>
<p>Runtime其实有两个版本:“modern”和 “legacy”。我们现在用的 Objective-C 2.0 采用的是现行(Modern)版的Runtime系统，只能运行在 iOS 和 OS X 10.5 之后的64位程序中。而OS X较老的32位程序仍采用 Objective-C 1中的（早期）Legacy 版本的 Runtime 系统。这两个版本最大的区别在于当你更改一个类的实例变量的布局时，在早期版本中你需要重新编译它的子类，而现行版就不需要。</p>
<p>Runtime基本是用C和汇编写的，可见苹果为了动态系统的高效而作出的努力。你可以在<a href="https://opensource.apple.com/source/objc4/" target="_blank" rel="noopener">这里</a>下到苹果维护的开源代码。苹果和GNU各自维护一个开源的runtime版本，这两个版本之间都在努力的保持一致。</p>
<h3 id="与Runtime交互"><a href="#与Runtime交互" class="headerlink" title="与Runtime交互"></a>与Runtime交互</h3><p>Objc 从<code>三种</code>不同的层级上与 Runtime 系统进行交互，分别是通过 <code>Objective-C 源代码</code>，通过 Foundation 框架的<code>NSObject类定义的方法</code>，通过对 <code>runtime 函数</code>的直接调用。</p>
<h4 id="Objective-C源代码"><a href="#Objective-C源代码" class="headerlink" title="Objective-C源代码"></a>Objective-C源代码</h4><p>大部分情况下你就只管写你的Objc代码就行，runtime 系统自动在幕后辛勤劳作着。<br>还记得引言中举的例子吧，消息的执行会使用到一些编译器为实现动态语言特性而创建的数据结构和函数，Objc中的类、方法和协议等在 runtime 中都由一些数据结构来定义，这些内容在后面会讲到。（比如<code>objc_msgSend</code>函数及其参数列表中的<code>id</code>和<code>SEL</code>都是啥）</p>
<h4 id="NSObject的方法"><a href="#NSObject的方法" class="headerlink" title="NSObject的方法"></a>NSObject的方法</h4><p>Cocoa 中大多数类都继承于<code>NSObject</code>类，也就自然继承了它的方法。最特殊的例外是<code>NSProxy</code>，它是个抽象超类，它实现了一些消息转发有关的方法，可以通过继承它来实现一个其他类的替身类或是虚拟出一个不存在的类，说白了就是领导把自己展现给大家风光无限，但是把活儿都交给幕后小弟去干。</p>
<p>有的<code>NSObject</code>中的方法起到了抽象接口的作用，比如<code>description</code>方法需要你重载它并为你定义的类提供描述内容。<code>NSObject</code>还有些方法能在运行时获得类的信息，并检查一些特性，比如<code>class</code>返回对象的类；<code>isKindOfClass</code>:和<code>isMemberOfClass:</code>则检查对象是否在指定的类继承体系中；<code>respondsToSelector:</code>检查对象能否响应指定的消息；<code>conformsToProtocol:</code>检查对象是否实现了指定协议类的方法；<code>methodForSelector:</code>则返回指定方法实现的地址。</p>
<h4 id="Runtime的函数"><a href="#Runtime的函数" class="headerlink" title="Runtime的函数"></a>Runtime的函数</h4><p>Runtime 系统是一个由一系列函数和数据结构组成，具有公共接口的动态共享库。头文件存放于<code>/usr/include/objc</code>目录下。许多函数允许你用纯C代码来重复实现 Objc 中同样的功能。虽然有一些方法构成了<code>NSObject</code>类的基础，但是你在写 Objc 代码时一般不会直接用到这些函数的，除非是写一些 Objc 与其他语言的桥接或是底层的debug工作。在<a href="https://developer.apple.com/reference/objectivec/1657527-objective_c_runtime" target="_blank" rel="noopener">Objective-C Runtime Reference</a>中有对 Runtime 函数的详细文档。</p>
<h3 id="Runtime术语"><a href="#Runtime术语" class="headerlink" title="Runtime术语"></a>Runtime术语</h3><p>还记得引言中的<code>objc_msgSend:</code>方法吧，它的真身是这样的</p>
<pre><code>id objc_msgSend ( id self, SEL op, ... );
</code></pre><p>下面将会逐渐展开介绍一些术语，其实它们都对应着数据结构。</p>
<h4 id="SEL"><a href="#SEL" class="headerlink" title="SEL"></a>SEL</h4><p><code>objc_msgSend</code>函数第二个参数类型为<code>SEL</code>，它是<code>selector</code>在Objc中的表示类型（Swift中是<code>Selector</code>类）。<code>selector</code>是方法选择器，可以理解为区分方法的标识，而这个标识的数据结构是SEL:</p>
<pre><code>typedef struct objc_selector *SEL;
</code></pre><p>本质上，SEL只是一个指向方法的指针（准确的说，只是一个根据方法名hash化了的KEY值，能唯一代表一个方法），它的存在只是为了加快方法的查询速度。这个查找过程我们将在下面讨论。</p>
<p>我们可以在运行时添加新的selector，也可以在运行时获取已存在的selector，我们可以通过下面三种方法来获取SEL:</p>
<ol>
<li><p>sel_registerName函数</p>
</li>
<li><p>Objective-C编译器提供的@selector()</p>
</li>
<li><p>NSSelectorFromString()方法</p>
</li>
</ol>
<h4 id="id"><a href="#id" class="headerlink" title="id"></a>id</h4><p><code>objc_msgSend</code>第一个参数类型为<code>id</code>，大家对它都不陌生，它是一个指向类实例的指针：</p>
<pre><code>typedef struct objc_object *id;
</code></pre><p>那<code>objc_object</code>又是啥呢：</p>
<pre><code>struct objc_object { Class isa; };
</code></pre><p><code>objc_object</code>结构体包含一个<code>isa</code>指针，根据<code>isa</code>指针就可以顺藤摸瓜找到对象所属的类。</p>
<p>PS:<code>isa</code>指针不总是指向实例对象所属的类，不能依靠它来确定类型，而是应该用<code>class</code>方法来确定实例对象的类。因为KVO的实现机理就是将被观察对象的isa指针指向一个中间类而不是真实的类，这是一种叫做 <strong>isa-swizzling</strong> 的技术，详见<a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/KeyValueObserving/Articles/KVOImplementation.html#//apple_ref/doc/uid/20002307-BAJEAIEE" target="_blank" rel="noopener">官方文档</a>的这句段说明</p>
<blockquote>
<p>Key-Value Observing Implementation Details</p>
</blockquote>
<blockquote>
<p>Automatic key-value observing is implemented using a technique called isa-swizzling.</p>
</blockquote>
<blockquote>
<p>The isa pointer, as the name suggests, points to the object’s class which maintains a dispatch table. This dispatch table essentially contains pointers to the methods the class implements, among other data.</p>
</blockquote>
<blockquote>
<p>When an observer is registered for an attribute of an object the isa pointer of the observed object is modified, pointing to an intermediate class rather than at the true class. As a result the value of the isa pointer does not necessarily reflect the actual class of the instance.</p>
</blockquote>
<blockquote>
<p>You should never rely on the isa pointer to determine class membership. Instead, you should use the class method to determine the class of an object instance.</p>
</blockquote>
<h4 id="Class"><a href="#Class" class="headerlink" title="Class"></a>Class</h4><p>之所以说<code>isa</code>是指针是因为<code>Class</code>其实是一个指向<code>objc_class</code>结构体的指针：</p>
<pre><code>typedef struct objc_class *Class;
</code></pre><p>而<code>objc_class</code>就是我们摸到的那个瓜，里面的东西多着呢：</p>
<pre><code>struct objc_class {
    Class isa  OBJC_ISA_AVAILABILITY;

#if !__OBJC2__
    Class super_class                                        OBJC2_UNAVAILABLE;
    const char *name                                         OBJC2_UNAVAILABLE;
    long version                                             OBJC2_UNAVAILABLE;
    long info                                                OBJC2_UNAVAILABLE;
    long instance_size                                       OBJC2_UNAVAILABLE;
    struct objc_ivar_list *ivars                             OBJC2_UNAVAILABLE;
    struct objc_method_list **methodLists                    OBJC2_UNAVAILABLE;
    struct objc_cache *cache                                 OBJC2_UNAVAILABLE;
    struct objc_protocol_list *protocols                     OBJC2_UNAVAILABLE;
#endif

} OBJC2_UNAVAILABLE;
</code></pre><p>可以看到运行时一个类还关联了它的超类指针，类名，成员变量，方法，缓存，还有附属的协议</p>
<p>PS:<code>OBJC2_UNAVAILABLE</code>之类的宏定义是苹果在 Objc 中对系统运行版本进行约束的黑魔法，为的是兼容非Objective-C 2.0的遗留逻辑，但我们仍能从中获得一些有价值的信息，有兴趣的可以查看源代码</p>
<p><code>Objective-C 2.0</code> 的头文件虽然没暴露出<code>objc_class</code>结构体更详细的设计，我们依然可以从<code>Objective-C 1.0</code> 的定义中小窥端倪</p>
<p>在<code>objc_class</code>结构体中：<code>ivars</code>是<code>objc_ivar_list</code>指针；<code>methodLists</code>是指向<code>objc_method_list</code>指针的指针。也就是说可以动态修改<code>*methodLists</code>的值来添加成员方法，这也是Category实现的原理，同样解释了Category不能添加属性的原因。而最新版的 Runtime 源码对这一块的描述已经有很大变化，可以参考下美团技术团队的<a href="http://tech.meituan.com/DiveIntoCategory.html" target="_blank" rel="noopener">深入理解Objective-C：Category</a>.</p>
<p>PS：任性的话可以在Category中添加<code>@dynamic</code>的属性，并利用运行期动态提供存取方法或干脆动态转发；或者干脆使用关联度对象（AssociatedObject）</p>
<p>其中<code>objc_ivar_list</code>和<code>objc_method_list</code>分别是成员变量列表和方法列表：</p>
<pre><code>struct objc_ivar_list {
    int ivar_count                                           OBJC2_UNAVAILABLE;
#ifdef __LP64__
    int space                                                OBJC2_UNAVAILABLE;
#endif
    /* variable length structure */
    struct objc_ivar ivar_list[1]                            OBJC2_UNAVAILABLE;
}                                                            OBJC2_UNAVAILABLE;

struct objc_method_list {
    struct objc_method_list *obsolete                        OBJC2_UNAVAILABLE;

    int method_count                                         OBJC2_UNAVAILABLE;
#ifdef __LP64__
    int space                                                OBJC2_UNAVAILABLE;
#endif
    /* variable length structure */
    struct objc_method method_list[1]                        OBJC2_UNAVAILABLE;
}
</code></pre><p>如果你C语言不是特别好，可以理解为<code>objc_ivar_list</code>结构体存储着<code>objc_ivar</code>数组列表，而<code>objc_ivar</code>结构体存储了类的单个成员变量的信息；同理<code>objc_method_list</code>结构体存储着<code>objc_method</code>数组列表，而o<code>bjc_method</code>结构体存储了类的某个方法的信息。</p>
<p>最后要提到的还有一个<code>objc_cache</code>，顾名思义它是缓存，它在<code>objc_class</code>的作用很重要，在后面会讲到。</p>
<p>不知道你是否注意到了<code>objc_class</code>中也有一个<code>isa</code>对象，这是因为一个 ObjC 类本身同时也是一个对象，为了处理类和对象的关系，runtime 库创建了一种叫做元类 (Meta Class) 的东西，类对象所属类型就叫做元类，它用来表述类对象本身所具备的元数据。类方法就定义于此处，因为这些方法可以理解成类对象的实例方法。每个类仅有一个类对象，而每个类对象仅有一个与之相关的元类。当你发出一个类似<code>[NSObject alloc]</code>的消息时，你事实上是把这个消息发给了一个类对象 (Class Object) ，这个类对象必须是一个元类的实例，而这个元类同时也是一个根元类 (root meta class) 的实例。所有的元类最终都指向根元类为其超类。所有的元类的方法列表都有能够响应消息的类方法。所以当 <code>[NSObject alloc]</code> 这条消息发给类对象的时候，<code>objc_msgSend()</code>会去它的元类里面去查找能够响应消息的方法，如果找到了，然后对这个类对象执行方法调用。</p>
<p><img src="http://7ni3rk.com1.z0.glb.clouddn.com/Runtime/class-diagram.jpg" alt></p>
<p>上图实线是 <code>super_class</code> 指针，虚线是<code>isa</code>指针。 有趣的是根元类的超类是<code>NSObjec</code>t，而<code>isa</code>指向了自己，而<code>NSObject</code>的超类为<code>nil</code>，也就是它没有超类</p>
<p>####Method</p>
<p><code>Method</code>是一种代表类中的某个方法的类型。</p>
<pre><code>typedef struct objc_method *Method;
</code></pre><p>而<code>objc_method</code>在上面的方法列表中提到过，它存储了方法名，方法类型和方法实现：</p>
<pre><code>struct objc_method {
    SEL method_name                                          OBJC2_UNAVAILABLE;
    char *method_types                                       OBJC2_UNAVAILABLE;
    IMP method_imp                                           OBJC2_UNAVAILABLE;
}                                                            OBJC2_UNAVAILABLE;

</code></pre><ul>
<li>方法名 <code>method_name</code> 类型为 <code>SEL</code>, 相同名字的方法即使在不同类中定义，它们的方法选择器也相同。</li>
<li>方法类型<code>method_types</code>是个<code>char</code>指针，存储着方法的 参数类型 和 返回值 类型。</li>
<li><code>method_imp</code>指向了方法的实现，本质上是一个函数指针，后面会详细讲到。</li>
</ul>
<h4 id="Ivar"><a href="#Ivar" class="headerlink" title="Ivar"></a>Ivar</h4><p>Ivar是一种代表类中实例变量的类型。定义如下：</p>
<pre><code>typedef struct objc_ivar *Ivar;
</code></pre><p>它是一个指向objc_ivar结构体的指针，结构体有如下定义:</p>
<pre><code>struct objc_ivar {
    char *ivar_name                                          OBJC2_UNAVAILABLE;
    char *ivar_type                                          OBJC2_UNAVAILABLE;
    int ivar_offset                                          OBJC2_UNAVAILABLE;
#ifdef __LP64__
    int space                                                OBJC2_UNAVAILABLE;
#endif
}                                                            OBJC2_UNAVAILABLE;
</code></pre><p>这里我们注意第三个成员 <code>ivar_offset</code>。它表示基地址偏移字节。</p>
<p>在编译我们的类时，编译器生成了一个 <code>ivar</code> 布局，显示了在类中从哪可以访问我们的 <code>ivars</code> 。</p>
<p>我们对 ivar 的访问就可以通过 <code>对象地址</code> ＋ <code>ivar偏移字节</code>的方法。</p>
<p>但是当我们增加了父类的<code>ivar</code>，这个时候布局就出错了，我们就不得不重新编译子类来恢复兼容性。</p>
<p>而Objective－C Runtime中使用了<code>Non Fragile ivars</code>来避免这个问题</p>
<p>使用<code>Non Fragile ivars</code>时，Runtime会进行检测来调整类中新增的<code>ivar</code>的偏移量。 这样我们就可以通过 <code>对象地址 ＋ 基类大小 + ivar偏移字节</code>的方法来计算出<code>ivar</code>相应的地址，并访问到相应的<code>ivar</code>。</p>
<p>可以根据实例查找其在类中的名字，也就是“反射”：</p>
<pre><code>-(NSString *)nameWithInstance:(id)instance {
    unsigned int numIvars = 0;
    NSString *key=nil;
    Ivar * ivars = class_copyIvarList([self class], &amp;numIvars);
    for(int i = 0; i &lt; numIvars; i++) {
        Ivar thisIvar = ivars[i];
        const char *type = ivar_getTypeEncoding(thisIvar);
        NSString *stringType =  [NSString stringWithCString:type encoding:NSUTF8StringEncoding];
        if (![stringType hasPrefix:@&quot;@&quot;]) {
            continue;
        }
        if ((object_getIvar(self, thisIvar) == instance)) {//此处若 crash 不要慌！
            key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
            break;
        }
    }
    free(ivars);
    return key;
}
</code></pre><p><code>class_copyIvarList</code> 函数获取的不仅有实例变量，还有属性。但会在原本的属性名前加上一个下划线。(属性的本质就是 <code>_属性名+set+get方法</code>)</p>
<h4 id="IMP"><a href="#IMP" class="headerlink" title="IMP"></a>IMP</h4><p><code>IMP</code>在<code>objc.h</code>中的定义是：</p>
<pre><code>typedef id (*IMP)(id, SEL, ...);
</code></pre><p>它就是一个<a href="http://yulingtianxia.com/blog/2014/04/17/han-shu-zhi-zhen-yu-zhi-zhen-han-shu/" target="_blank" rel="noopener">函数指针</a>，这是由编译器生成的。当你发起一个 ObjC 消息之后，最终它会执行的那段代码，就是由这个函数指针指定的。而 <code>IMP</code> 这个函数指针就指向了这个方法的实现。既然得到了执行某个实例某个方法的入口，我们就可以绕开消息传递阶段，直接执行方法，这在后面会提到。</p>
<p>我们再来看看objc_msgSend()的定义：<code>id objc_msgSend(id self, SEL op, ...)</code></p>
<p>你会发现<code>IMP</code>指向的方法与<code>objc_msgSend</code>函数类型相同，参数都包含id和SEL类型。每个方法名都对应一个SEL类型的方法选择器，而每个实例对象中的<code>SEL</code>对应的方法实现肯定是唯一的，通过一组<code>id</code>和<code>SEL</code>参数就能确定唯一的方法实现地址。</p>
<h4 id="Cache"><a href="#Cache" class="headerlink" title="Cache"></a>Cache</h4><p>在<code>runtime.h</code>中Cache的定义如下：</p>
<pre><code>typedef struct objc_cache *Cache
</code></pre><p>还记得之前 <code>objc_class</code> 结构体中有一个 <code>struct objc_cache *cache</code> 吧，它到底是缓存啥的呢，先看看 <code>objc_cache</code> 的实现：</p>
<pre><code>struct objc_cache {
    unsigned int mask /* total = mask + 1 */                 OBJC2_UNAVAILABLE;
    unsigned int occupied                                    OBJC2_UNAVAILABLE;
    Method buckets[1]                                        OBJC2_UNAVAILABLE;
};
</code></pre><p><code>objc_cache</code> 的定义看起来很简单，它包含了下面三个变量：</p>
<ul>
<li><code>mask</code>:可以认为是当前能达到的最大index（从0开始的），所以缓存的size（total）是mask+1</li>
<li><code>occupied</code>:被占用的槽位，因为缓存是以散列表的形式存在的，所以会有空槽，而occupied表示当前被占用的数目</li>
<li><code>buckets</code>:用数组表示的hash表，cache_entry类型，每一个cache_entry代表一个方法缓存</li>
</ul>
<p>(buckets定义在objc_cache的最后，说明这是一个可变长度的数组)</p>
<p><code>Cache</code>为方法调用的性能进行优化,下面我们来看看<code>objc_msgSend</code>具体又是如何分发的呢？ 我们来看下runtime层<code>objc_msgSend</code>的源码。</p>
<p>在<code>objc-msg-arm.s</code>中，<code>objc_msgSend</code>的代码如下：</p>
<p>ps：Apple为了高度优化objc_msgSend的性能，这个文件是汇编写成的，不过即使我们不懂汇编，详尽的注释也可以让我们一窥其真面目</p>
<pre><code>ENTRY objc_msgSend
# check whether receiver is nil
teq     a1, #0
    beq     LMsgSendNilReceiver
# save registers and load receiver&#39;s class for CacheLookup
stmfd   sp!, {a4,v1}
ldr     v1, [a1, #ISA]
# receiver is non-nil: search the cache
CacheLookup a2, v1, LMsgSendCacheMiss
# cache hit (imp in ip) and CacheLookup returns with nonstret (eq) set, restore registers and call
ldmfd   sp!, {a4,v1}
bx      ip
# cache miss: go search the method lists
LMsgSendCacheMiss:
ldmfd sp!, {a4,v1}
b _objc_msgSend_uncached
LMsgSendNilReceiver:
    mov     a2, #0
    bx      lr
LMsgSendExit:
END_ENTRY objc_msgSend
STATIC_ENTRY objc_msgSend_uncached
# Push stack frame
stmfd sp!, {a1-a4,r7,lr}
add     r7, sp, #16
# Load class and selector
ldr a3, [a1, #ISA] /* class = receiver-&gt;isa  */
/* selector already in a2 */
/* receiver already in a1 */
# Do the lookup
MI_CALL_EXTERNAL(__class_lookupMethodAndLoadCache3)
MOVE    ip, a1
# Prep for forwarding, Pop stack frame and call imp
teq v1, v1 /* set nonstret (eq) */
ldmfd sp!, {a1-a4,r7,lr}
bx ip
</code></pre><p>如果向更深入了解 <code>objc_cache</code> ,可以看看这篇博文<a href="http://www.cocoachina.com/ios/20150818/13075.html" target="_blank" rel="noopener">深入理解Objective-C：方法缓存</a></p>
<p>从上述代码中可以看到，<code>objc_msgSend</code>（就ARM平台而言）的消息分发分为以下几个步骤：</p>
<ol>
<li>判断receiver是否为nil，也就是objc_msgSend的第一个参数self，也就是要调用的那个方法所属对象</li>
<li>从缓存里寻找，找到了则分发，否则</li>
<li>利用objc-class.mm中_class_lookupMethodAndLoadCache3（为什么有个这么奇怪的方法。本文末尾会解释）方法去寻找selector</li>
<li>如果支持GC，忽略掉非GC环境的方法（retain等）</li>
<li>从本class的method list寻找selector，如果找到，填充到缓存中，并返回selector，否则</li>
<li>寻找父类的method list，并依次往上寻找，直到找到selector，填充到缓存中，并返回selector，否则</li>
<li>调用_class_resolveMethod，如果可以动态resolve为一个selector，不缓存，方法返回，否则</li>
<li>转发这个selector，否则</li>
<li>报错，抛出异常</li>
</ol>
<p>从上面的分析中我们可以看到，当一个方法在比较“上层”的类中，用比较“下层”（继承关系上的上下层）对象去调用的时候，如果没有缓存，那么整个查找链是相当长的。就算方法是在这个类里面，当方法比较多的时候，每次都查找也是费事费力的一件事情。</p>
<p>当我们需要去调用一个方法数十万次甚至更多地时候，查找方法的消耗会变的非常显著。就算我们平常的非大规模调用，<code>除非一个方法只会调用一次，否则缓存都是有用的。</code>在运行时，那么多对象，那么多方法调用，节省下来的时间也是非常可观的。可见缓存的重要性。</p>
<p>方法缓存存在什么地方？</p>
<p>让我们再去去翻看 <code>objc_class</code> 的定义，</p>
<pre><code>struct objc_class {
    Class isa  OBJC_ISA_AVAILABILITY;

#if !__OBJC2__
    Class super_class                                        OBJC2_UNAVAILABLE;
    const char *name                                         OBJC2_UNAVAILABLE;
    long version                                             OBJC2_UNAVAILABLE;
    long info                                                OBJC2_UNAVAILABLE;
    long instance_size                                       OBJC2_UNAVAILABLE;
    struct objc_ivar_list *ivars                             OBJC2_UNAVAILABLE;
    struct objc_method_list **methodLists                    OBJC2_UNAVAILABLE;
    struct objc_cache *cache                                 OBJC2_UNAVAILABLE;
    struct objc_protocol_list *protocols                     OBJC2_UNAVAILABLE;
#endif

} OBJC2_UNAVAILABLE;
</code></pre><p>我们看到在类的定义里就有<code>cache</code>字段，没错，类的所有缓存都存在metaclass上，所以每个类都只有一份方法缓存，而不是每一个类的object都保存一份。</p>
<p>子类类即便是从父类取到的方法，也会存在类本身的方法缓存里。而当用一个父类对象去调用那个方法的时候，也会在父类的metaclass里缓存一份。</p>
<h4 id="Property"><a href="#Property" class="headerlink" title="Property"></a>Property</h4><p><code>@property</code>标记了类中的属性，这个不必多说大家都很熟悉，它是一个指向objc_property结构体的指针：</p>
<pre><code>typedef struct objc_property *Property;
typedef struct objc_property *objc_property_t;//这个更常用
</code></pre><p>现在在类中声明声明属性和成员变量：</p>
<pre><code>@interface ViewController ()
{
    int age;
    NSString *name;
}
@property (nonatomic, strong) NSString *property1;
@property (nonatomic, strong) NSString *property2;
@property (nonatomic, assign) int age;//这里的age为属性，对应变量：_age
@property (nonatomic, assign) long ID;

@end
</code></pre><p>然后用下面的方法来获取类中属性列表：</p>
<pre><code>id LenderClass = objc_getClass(&quot;ViewController&quot;);//获取calss
//id LenderClass = [MyViewController class];//同上
unsigned int outCount;//属性数量
objc_property_t *properties = class_copyPropertyList(LenderClass, &amp;outCount);//获取属性列表
for (int i = 0; i &lt; outCount; i++) {// 遍历
    objc_property_t property = properties[i];
    const char *propertyName = property_getName(property);
    const char *propertyAttributes = property_getAttributes(property);
    printf(&quot;propertyName：%s \n&quot;, propertyName);
    printf(&quot;propertyAttributes:%s\n--------\n&quot;, propertyAttributes);//属性名及描述
}
</code></pre><p>控制台输出：</p>
<pre><code>propertyName：property1 
propertyAttributes:T@&quot;NSString&quot;,&amp;,N,V_property1
--------
propertyName：property2 
propertyAttributes:T@&quot;NSString&quot;,&amp;,N,V_property2
--------
propertyName：age 
propertyAttributes:Ti,N,V_age
--------
propertyName：ID 
propertyAttributes:Tq,N,V_ID
</code></pre><p>我们再来来看看获取成员变量的方法：</p>
<pre><code>id selfClass = [self class];
unsigned int numIvars = 0;
Ivar *ivars = class_copyIvarList(selfClass, &amp;numIvars);
for(int i = 0; i &lt; numIvars; i++) {
    Ivar ivar = ivars[i];
    const char *ivarType = ivar_getTypeEncoding(ivar);// 获取类型
    const char *ivarName = ivar_getName(ivar);
    printf(&quot;ivarName:%s\n&quot;, ivarName);
    printf(&quot;ivarType:%s\n------\n&quot;, ivarType);
}
</code></pre><p>控制台输出：</p>
<pre><code>ivarName:age
ivarType:i
------
ivarName:name
ivarType:@&quot;NSString&quot;
------
ivarName:_age
ivarType:i
------
ivarName:_property1
ivarType:@&quot;NSString&quot;
------
ivarName:_property2
ivarType:@&quot;NSString&quot;
------
ivarName:_ID
ivarType:q
</code></pre><p>我们会发现与 <code>class_copyIvarList</code> 函数不同，使用 <code>class_copyPropertyList</code> 函数只能获取类的属性，而不包含成员变量。但此时获取的属性名是不带下划线的,得到属性或者变量名后我们就可以使用KVC去修改访问类中的私有属性或变量。所以OC中没有真正意义上的私有变量，私有方法也是。</p>
<h3 id="消息"><a href="#消息" class="headerlink" title="消息"></a>消息</h3><p>前面做了这么多铺垫，现在终于说到了消息了。Objc 中发送消息是用中括号 <code>[]</code> 把接收者和消息括起来，而直到运行时才会把消息与方法实现绑定。</p>
<p>有关消息发送和消息转发机制的原理，可以查看<a href="http://yulingtianxia.com/blog/2016/06/15/Objective-C-Message-Sending-and-Forwarding/" target="_blank" rel="noopener">这篇文章</a>。</p>
<h4 id="objc-msgSend函数"><a href="#objc-msgSend函数" class="headerlink" title="objc_msgSend函数"></a>objc_msgSend函数</h4><p>在引言中已经对 <code>objc_msgSend</code> 进行了一点介绍，看起来像是 <code>objc_msgSend</code> 返回了数据，其实 <code>objc_msgSend</code> 从不返回数据而是你的方法被调用后返回了数据。下面详细叙述下消息发送步骤：</p>
<ol>
<li>检测这个 消息 是不是要忽略的。比如 Mac OS X 开发，在ARC中有了垃圾回收就不理会MRC的 <code>retain</code>, <code>release</code> 这些函数了。</li>
<li>检测这个 目标对象 是不是 <code>nil</code> 对象。ObjC 的特性是允许对一个 <code>nil</code> 对象执行任何一个方法不会 Crash，因为会被忽略掉。</li>
<li>如果上面两个都过了，那就开始查找这个类的 <code>IMP</code>，先从 <code>cache</code> 里面找，完了找得到就跳到对应的函数去执行。</li>
<li>如果 <code>cache</code> 找不到就找一下方法分发表。</li>
<li>如果分发表找不到就到超类的分发表去找，一直找，直到找到NSObject类为止。</li>
<li>如果还找不到就要开始进入动态方法解析了，后面会提到。</li>
</ol>
<p>PS:这里说的分发表其实就是 <code>Class</code> 中的方法列表，它将方法选择器和方法实现地址联系起来。<br><img src="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Art/messaging1.gif" alt></p>
<p>其实编译器会根据情况在<code>objc_msgSend</code>, <code>objc_msgSend_stret</code>, <code>objc_msgSendSuper</code>, 或 <code>objc_msgSendSuper_stret</code>四个方法中选择一个来调用。如果消息是传递给超类，那么会调用名字带有”Super”的函数；如果消息返回值是数据结构而不是简单值时，那么会调用名字带有<code>”stret”</code>的函数。排列组合正好四个方法</p>
<p>PS：有木有发现这些函数的命名规律哦？带 <code>“Super”</code> 的是消息传递给超类；<code>“stret”</code>可分为<code>“st”</code>+<code>“ret”</code>两部分，分别代表 <code>“struct”</code> 和 <code>“return”</code> ；<code>“fpret”</code>就是 <code>“fp”</code> + <code>“ret”</code>，分别代表<code>“floating-point”</code>和 <code>“return”</code>。</p>
<h4 id="方法中的隐藏参数"><a href="#方法中的隐藏参数" class="headerlink" title="方法中的隐藏参数"></a>方法中的隐藏参数</h4><p>我们经常在方法中使用 <code>self</code> 关键字来引用实例本身，但从没有想过为什么 <code>self</code> 就能取到调用当前方法的对象吧。其实 <code>self</code> 的内容是在方法运行时被偷偷的动态传入的</p>
<p>当 <code>objc_msgSend</code> 找到方法对应的实现时，它将直接调用该方法实现，并将消息中所有的参数都传递给方法实现,同时,它还将传递两个隐藏的参数:</p>
<ul>
<li>接收消息的对象（也就是<code>self</code>指向的内容）</li>
<li>方法选择器（<code>_cmd</code>指向的内容）</li>
</ul>
<p>之所以说它们是隐藏的是因为在源代码方法的定义中并没有声明这两个参数。它们是在代码被编译时被插入实现中的。尽管这些参数没有被明确声明，在源代码中我们仍然可以引用它们。在下面的例子中，<code>self</code>引用了接收者对象，而<code>_cmd</code>引用了方法本身的选择器：</p>
<pre><code>- strange
{
    id  target = getTheReceiver();
    SEL method = getTheMethod();

    if ( target == self || method == _cmd )
        return nil;
    return [target performSelector:method];
}
</code></pre><p>在这两个参数中，<code>self</code> 更有用。实际上,它是在方法实现中访问消息接收者对象的实例变量的途径</p>
<p>而当方法中的 <code>super</code> 关键字接收到消息时，编译器会创建一个 <code>objc_super</code> 结构体：</p>
<pre><code>struct objc_super { id receiver; Class class; };
</code></pre><p>这个结构体指明了消息应该被传递给特定父类的定义。但<code>receiver</code>仍然是<code>self</code>本身，这点需要注意，因为当我们想通过<code>[super class]</code>获取超类时，编译器只是将指向<code>self</code>的<code>id</code>指针和<code>class</code>的<code>SEL</code>传递给了o<code>bjc_msgSendSuper</code>函数，因为只有在<code>NSObject</code>类才能找到<code>class</code>方法，然后<code>class</code>方法调用<code>object_getClass()</code>，接着调用<code>objc_msgSend(objc_super-&gt;receiver</code>, <code>@selector(class))</code>，传入的第一个参数是指向<code>self</code>的<code>id</code>指针，与调用<code>[self class]</code>相同，所以我们得到的永远都是<code>self</code>的类型。</p>
<h4 id="获取方法地址"><a href="#获取方法地址" class="headerlink" title="获取方法地址"></a>获取方法地址</h4><p>在 <code>IMP</code> 那节提到过可以避开消息绑定而直接获取方法的地址并调用方法。这种做法很少用，除非是需要持续大量重复调用某方法的极端情况，避开消息发送泛滥而直接调用该方法会更高效。<br>NSObject类中有个<code>methodForSelector:</code>实例方法，你可以用它来获取某个方法选择器对应的 <code>IMP</code> ，举个栗子：</p>
<pre><code>void (*imp)(id, SEL, BOOL);//定义一个函数指针
imp = (void (*)(id, SEL, BOOL))[self methodForSelector:@selector(setFilled:)];//获取setFilled:函数的IMP
</code></pre><h3 id="动态方法解析"><a href="#动态方法解析" class="headerlink" title="动态方法解析"></a>动态方法解析</h3><p>你可以动态地提供一个方法的实现。例如我们可以用 <code>@dynamic</code> 关键字在类的实现文件中修饰一个属性：</p>
<pre><code>@dynamic propertyName;
</code></pre><p>这表明我们会为这个属性提供存取方法，也就是说编译器不会默认为我们生成 <code>setPropertyName:</code>和 <code>prepertyName</code> 方法，而需要我们自己提供动态方法。我们可以通过分别重载 <code>resolveIntanceMethod：</code> 和 <code>resolvrClassMethod:</code> 方法分别添加实例方法实现和类方法实现。因为当 Runtime 系统在 <code>Cache</code> 和方法分发表中（包括父类）找不到要执行的方法时，Runtime会调用 <code>resolveIntanceMethod：</code> 和 <code>resolvrClassMethod:</code> 来给我们一次动态添加实现的机会。我们需要 <code>class_addMethod</code>函数完成向特定类添加特定方法实现的操作：</p>
<pre><code>void dynamicMethodIMP(id self, SEL _cmd) {
    // implementation ....
}
@implementation MyClass
+ (BOOL)resolveInstanceMethod:(SEL)aSEL
{
    if (aSEL == @selector(resolveThisMethodDynamically)) {
          class_addMethod([self class], aSEL, (IMP) dynamicMethodIMP, &quot;v@:&quot;);
          return YES;
    }
    return [super resolveInstanceMethod:aSEL];
}
@end

</code></pre><p>上面的例子为resolveThisMethodDynamically方法添加了实现内容，也就是dynamicMethodIMP方法中的代码。其中 “v@:” 表示返回值和参数，这个符号涉及 <a href="https://developer.apple.com/library/mac/DOCUMENTATION/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtTypeEncodings.html" target="_blank" rel="noopener">Type Encoding</a></p>
<p>PS：动态方法解析会在消息转发机制浸入前执行。如果 <code>respondsToSelector:</code> 或 <code>instancesRespondToSelector:</code> 方法被执行，动态方法解析器将会被首先给予一个提供该方法选择器对应的 <code>IMP</code> 的机会。如果你想让该方法选择器被传送到转发机制，那么就让<code>resolveInstanceMethod:</code> 返回 <code>NO</code> 。</p>
<h3 id="消息转发"><a href="#消息转发" class="headerlink" title="消息转发"></a>消息转发</h3><h4 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h4><p>在消息转发机制执行前，Runtime 系统会再给我们一次偷梁换柱的机会，即通过重载<code>- (id)forwardingTargetForSelector:(SEL)aSelector</code> 方法替换消息的接受者为其他对象：</p>
<pre><code>- (id)forwardingTargetForSelector:(SEL)aSelector
{
    if(aSelector == @selector(mysteriousMethod:)){
        return alternateObject;
    }
    return [super forwardingTargetForSelector:aSelector];
}
</code></pre><p>毕竟消息转发要耗费更多时间，抓住这次机会将消息重定向给别人是个不错的选择，不过千万别返回<code>self</code>，因为那样会死循环</p>
<h4 id="转发"><a href="#转发" class="headerlink" title="转发"></a>转发</h4><p>当动态方法解析不作处理返回NO时，消息转发机制会被触发。在这时<code>forwardInvocation:</code>方法会被执行，我们可以重写这个方法来定义我们的转发逻辑：</p>
<pre><code>- (void)forwardInvocation:(NSInvocation *)anInvocation
{
    if ([someOtherObject respondsToSelector:
            [anInvocation selector]])
        [anInvocation invokeWithTarget:someOtherObject];
    else
        [super forwardInvocation:anInvocation];
}
</code></pre><p>该消息的唯一参数是个<code>NSInvocation</code>类型的对象——该对象封装了原始的消息和消息的参数。我们可以实现<code>forwardInvocation:</code>方法来对不能处理的消息做一些默认的处理，也可以将消息转发给其他对象来处理，而不抛出错误。</p>
<p>当一个对象由于没有相应的方法实现而无法响应某消息时，运行时系统将通过 <code>forwardInvocation:</code> 消息通知该对象。每个对象都从NSObject类中继承了 <code>forwardInvocation:</code> 方法。然而，NSObject中的方法实现只是简单地调用了 <code>doesNotRecognizeSelector:</code> 。通过实现我们自己的 <code>forwardInvocation:</code> 方法，我们可以在该方法实现中将消息转发给其它对象。</p>
<p><code>forwardInvocation:</code> 方法就像一个不能识别的消息的分发中心，将这些消息转发给不同接收对象。或者它也可以象一个运输站将所有的消息都发送给同一个接收对象。它可以将一个消息翻译成另外一个消息，或者简单的”吃掉“某些消息，因此没有响应也没有错误。<code>forwardInvocation:</code>方法也可以对不同的消息提供同样的响应，这一切都取决于方法的具体实现。该方法所提供是将不同的对象链接到消息链的能力。</p>
<p>注意： <code>forwardInvocation:</code> 方法只有在消息接收对象中无法正常响应消息时才会被调用。 所以，如果我们希望一个对象将negotiate消息转发给其它对象，则这个对象不能有<code>negotiate</code>方法。否则，<code>forwardInvocation:</code>将不可能会被调用。</p>
<h4 id="转发和多继承"><a href="#转发和多继承" class="headerlink" title="转发和多继承"></a>转发和多继承</h4><p>转发和继承相似，可以用于为Objc编程添加一些多继承的效果。就像下图那样，一个对象把消息转发出去，就好似它把另一个对象中的方法借过来或是“继承”过来一样。</p>
<p><img src="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Art/forwarding.gif" alt></p>
<p>这使得不同继承体系分支下的两个类可以“继承”对方的方法，在上图中 <code>Warrior</code> 和 <code>Diplomat</code> 没有继承关系，但是 <code>Warrior</code> 将<code>negotiate</code> 消息转发给了 <code>Diplomat</code> 后，就好似 <code>Diplomat</code> 是 <code>Warrior</code> 的超类一样。<br>消息转发弥补了 Objc 不支持多继承的性质，也避免了因为多继承导致单个类变得臃肿复杂。它将问题分解得很细，只针对想要借鉴的方法才转发，而且转发机制是透明的</p>
<h4 id="替代者对象-Surrogate-Objects"><a href="#替代者对象-Surrogate-Objects" class="headerlink" title="替代者对象(Surrogate Objects)"></a>替代者对象(Surrogate Objects)</h4><p>转发不仅能模拟多继承，也能使轻量级对象代表重量级对象。弱小的女人背后是强大的男人，毕竟女人遇到难题都把它们转发给男人来做了。这里有一些适用案例，可以参看<a href="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtForwarding.html#//apple_ref/doc/uid/TP40008048-CH105-SW11" target="_blank" rel="noopener">官方文档</a>。</p>
<h4 id="转发于继承"><a href="#转发于继承" class="headerlink" title="转发于继承"></a>转发于继承</h4><p>尽管转发很像继承，但是NSObject类不会将两者混淆。像 <code>respondsToSelector:</code> 和 <code>isKindOfClass:</code> 这类方法只会考虑继承体系，不会考虑转发链。比如上图中一个 <code>Warrior</code> 对象如果被问到是否能响应 <code>negotiate</code> 消息：</p>
<pre><code>if ( [aWarrior respondsToSelector:@selector(negotiate)] )
    ...
</code></pre><p>结果是 <code>NO</code> ，尽管它能够接受 <code>negotiate</code> 消息而不报错，因为它靠转发消息给 <code>Diplomat</code> 类来响应消息。</p>
<p>如果你为了某些意图偏要“弄虚作假”让别人以为<code>Warrior</code> 继承到了 <code>Diplomat</code> 的 <code>negotiate</code> 方法，你得重新实现 <code>respondsToSelector:</code> 和 <code>isKindOfClass:</code> 来加入你的转发算法：</p>
<pre><code>- (BOOL)respondsToSelector:(SEL)aSelector
{
    if ( [super respondsToSelector:aSelector] )
        return YES;
    else {
        /* Here, test whether the aSelector message can     *
         * be forwarded to another object and whether that  *
         * object can respond to it. Return YES if it can.  */
    }
    return NO;
}
</code></pre><p>除了<code>respondsToSelector:</code>和 <code>isKindOfClass:</code>之外，<code>instancesRespondToSelector:</code>中也应该写一份转发算法。如果使用了协议，<code>conformsToProtocol:</code>同样也要加入到这一行列中。类似地，如果一个对象转发它接受的任何远程消息，它得给出一个<code>methodSignatureForSelector:</code>来返回准确的方法描述，这个方法会最终响应被转发的消息。比如一个对象能给它的替代者对象转发消息，它需要像下面这样实现<code>methodSignatureForSelector:</code>:</p>
<pre><code>- (NSMethodSignature*)methodSignatureForSelector:(SEL)selector
{
    NSMethodSignature* signature = [super methodSignatureForSelector:selector];
    if (!signature) {
       signature = [surrogate methodSignatureForSelector:selector];
    }
    return signature;
}
</code></pre><h3 id="健壮的实例变量-Non-Fragile-ivars"><a href="#健壮的实例变量-Non-Fragile-ivars" class="headerlink" title="健壮的实例变量(Non Fragile ivars)"></a>健壮的实例变量(Non Fragile ivars)</h3><p>在 Runtime 的现行版本中，最大的特点就是健壮的实例变量。当一个类被编译时，实例变量的布局也就形成了，它表明访问类的实例变量的位置。从对象头部地址开始，实例变量依次根据自己所占空间而产生位移：</p>
<p>再翻出Ivar的定义：</p>
<pre><code>struct objc_ivar {
    char *ivar_name                                          OBJC2_UNAVAILABLE;
    char *ivar_type                                          OBJC2_UNAVAILABLE;
    int ivar_offset                                          OBJC2_UNAVAILABLE;
#ifdef __LP64__
    int space                                                OBJC2_UNAVAILABLE;
#endif
}                                                            OBJC2_UNAVAILABLE;
</code></pre><p><code>ivar</code> 的访问可以通过 <code>对象地址</code> ＋ <code>ivar偏移字节(ivar_offset)</code>的方法。</p>
<p>当我们增加了父类的<code>ivar</code>，这个时候布局就出错了，我们就不得不重新编译子类来恢复兼容性。</p>
<p>在健壮的实例变量下编译器生成的实例变量布局跟以前一样，但是当 runtime 系统检测到与超类有部分重叠时它会调整你新添加的实例变量的位移，那样你在子类中新添加的成员就被保护起来了</p>
<p>需要注意的是在健壮的实例变量下，不要使用 <code>sizeof(SomeClass)</code>，而是用 <code>class_getInstanceSize([SomeClass class])</code> 代替；也不要使用 <code>offsetof(SomeClass, SomeIvar)</code> ，而要用 <code>ivar_getOffset(class_getInstanceVariable([SomeClass class], &quot;SomeIvar&quot;))</code> 来代替。</p>
<pre><code>/* 定义一个Student类 */
@interface Student : NSObject
{
@private
    int age;
}
@end

@implementation Student
// 重写%@输出方法
- (NSString *)description
{
    NSLog(@&quot;current pointer = %p&quot;, self);
    NSLog(@&quot;age pointer = %p&quot;, &amp;age);
    return [NSString stringWithFormat:@&quot;age = %d&quot;, age];
}

@end

int main(int argc, const char * argv[]) {
    @autoreleasepool {
        // insert code here...

        Student *student = [[Student alloc] init];
        Ivar age_ivar = class_getInstanceVariable(object_getClass(student), &quot;age&quot;);//获取&quot;age&quot;的ivar
        int *age_pointer = (int *)((__bridge void *)(student) + ivar_getOffset(age_ivar));//定义一个指向age_ivar的指针：指向地址为 student对象地址 + age_ivar的偏移量（ivar_offset）
        NSLog(@&quot;age ivar offset = %td&quot;, ivar_getOffset(age_ivar));//输出offset偏移量
        *age_pointer = 10;//对指针age_pointer指向的变量（age_ivar）赋值
        NSLog(@&quot;%@&quot;, student);//输出重写的description方法

    }
    return 0;
}
</code></pre><p>观察控制台输出：</p>
<pre><code>2016-11-11 16:22:56.364 Iavr_offset[1501:928608] age ivar offset = 8
2016-11-11 16:22:56.365 Iavr_offset[1501:928608] current pointer = 0x100400170
2016-11-11 16:22:56.365 Iavr_offset[1501:928608] age pointer = 0x100400178
2016-11-11 16:22:56.366 Iavr_offset[1501:928608] age = 10
</code></pre><p>我们发现<code>age pointer = current pointer + age ivar offset</code></p>
<h3 id="Objective-C-Associated-Objects"><a href="#Objective-C-Associated-Objects" class="headerlink" title="Objective-C Associated Objects"></a>Objective-C Associated Objects</h3><p>在 OS X 10.6 之后，Runtime系统让Objc支持向对象动态添加变量。涉及到的函数有以下三个：</p>
<pre><code> void objc_setAssociatedObject ( id object, const void *key, id value, objc_AssociationPolicy policy );
 id objc_getAssociatedObject ( id object, const void *key );
 void objc_removeAssociatedObjects ( id object );
</code></pre><p>这些方法以键值对的形式动态地向对象添加、获取或删除关联值。其中关联政策是一组枚举常量：</p>
<pre><code>enum {
   OBJC_ASSOCIATION_ASSIGN  = 0,
   OBJC_ASSOCIATION_RETAIN_NONATOMIC  = 1,
   OBJC_ASSOCIATION_COPY_NONATOMIC  = 3,
   OBJC_ASSOCIATION_RETAIN  = 01401,
   OBJC_ASSOCIATION_COPY  = 01403
};
</code></pre><p>这些常量对应着引用关联值的政策，也就是 Objc 内存管理的引用计数机制。</p>
<h3 id="Method-Swizzling"><a href="#Method-Swizzling" class="headerlink" title="Method Swizzling"></a>Method Swizzling</h3><p>之前所说的消息转发虽然功能强大，但需要我们了解并且能更改对应类的源代码，因为我们需要实现自己的转发逻辑。当我们无法触碰到某个类的源代码，却想更改这个类某个方法的实现时，该怎么办呢？可能继承类并重写方法是一种想法，但是有时无法达到目的。这里介绍的是 Method Swizzling ，它通过重新映射方法对应的实现来达到“偷天换日”的目的。跟消息转发相比，Method Swizzling 的做法更为隐蔽，甚至有些冒险，也增大了debug的难度。</p>
<p>这里摘抄一个 NSHipster 的例子</p>
<pre><code>#import &lt;objc/runtime.h&gt; 

@implementation UIViewController (Tracking)

+ (void)load {
    static dispatch_once_t onceToken;
    dispatch_once(&amp;onceToken, ^{
        Class class = [self class];
        // When swizzling a class method, use the following: 
        // Class class = object_getClass((id)self); 
        SEL originalSelector = @selector(viewWillAppear:);
        SEL swizzledSelector = @selector(xxx_viewWillAppear:);
        Method originalMethod = class_getInstanceMethod(class, originalSelector);
        Method swizzledMethod = class_getInstanceMethod(class, swizzledSelector);
        BOOL didAddMethod =
            class_addMethod(class,
                originalSelector,
                method_getImplementation(swizzledMethod),
                method_getTypeEncoding(swizzledMethod));
        if (didAddMethod) {
            class_replaceMethod(class,
                swizzledSelector,
                method_getImplementation(originalMethod),
                method_getTypeEncoding(originalMethod));
        } else {
            method_exchangeImplementations(originalMethod, swizzledMethod);
        }
    });
}
#pragma mark - Method Swizzling 
- (void)xxx_viewWillAppear:(BOOL)animated {
    [self xxx_viewWillAppear:animated];
    NSLog(@&quot;viewWillAppear: %@&quot;, self);
}
@end
</code></pre><p>上面的代码通过添加一个 <code>Tracking</code> 类别到 <code>UIViewController</code> 类中，将 <code>UIViewController</code> 类的 <code>viewWillAppear:</code> 方法和 <code>Tracking</code> 类别中 <code>xxx_viewWillAppear:</code> 方法的实现相互调换。<code>Swizzling</code> 应该在 <code>+load</code> 方法中实现，因为 <code>+load</code> 是在一个类最开始加载时调用。<code>dispatch_once</code> 是GCD中的一次性方法，它保证了代码块只执行一次，并让其为一个原子操作，线程安全是很重要的。</p>
<p>先用 <code>class_addMethod</code> 和 <code>class_replaceMethod</code> 函数将两个方法的实现进行调换，如果类中已经有了 <code>viewWillAppear:</code> 方法的实现，那么就调用 <code>method_exchangeImplementations</code> 函数交换了两个方法的 <code>IMP</code> ，这是苹果提供给我们用于实现 <code>Method Swizzling</code> 的便捷方法。<br>最后 <code>xxx_viewWillAppear:</code> 方法的定义看似是递归调用引发死循环，其实不会的。因为 <code>[self xxx_viewWillAppear:animated]</code> 消息会动态找到 <code>xxx_viewWillAppear:</code> 方法的实现，而它的实现已经被我们与 <code>viewWillAppear:</code>方法实现进行了互换，所以这段代码不仅不会死循环，如果你把 <code>[self xxx_viewWillAppear:animated]</code> 换成 <code>[self viewWillAppear:animated]</code> 反而会引发死循环。<br>看到有人说 <code>+load</code>方法本身就是线程安全的，因为它在程序刚开始就被调用，很少会碰到并发问题，于是 <code>stackoverflow</code> 上也有大神给出了另一个 <code>Method Swizzling</code> 的实现：</p>
<pre><code>- (void)replacementReceiveMessage:(const struct BInstantMessage *)arg1 {
    NSLog(@&quot;arg1 is %@&quot;, arg1);
    [self replacementReceiveMessage:arg1];
}
+ (void)load {
    SEL originalSelector = @selector(ReceiveMessage:);
    SEL overrideSelector = @selector(replacementReceiveMessage:);
    Method originalMethod = class_getInstanceMethod(self, originalSelector);
    Method overrideMethod = class_getInstanceMethod(self, overrideSelector);
    if (class_addMethod(self, originalSelector, method_getImplementation(overrideMethod), method_getTypeEncoding(overrideMethod))) {
            class_replaceMethod(self, overrideSelector, method_getImplementation(originalMethod), method_getTypeEncoding(originalMethod));
    } else {
            method_exchangeImplementations(originalMethod, overrideMethod);
    }
}
</code></pre><p>其实也就是去掉了<code>dispatch_once</code>的部分罢了。</p>
<p><code>Method Swizzling</code> 的确是一个值得深入研究的话题，<code>Method Swizzling</code> 的最佳实现是什么呢？小弟才疏学浅理解的不深刻，找了几篇不错的资源推荐给大家：</p>
<ul>
<li><a href="http://blog.csdn.net/yiyaaixuexi/article/details/9374411" target="_blank" rel="noopener">Objective-C的hook方案（一）: Method Swizzling</a></li>
<li><a href="http://nshipster.com/method-swizzling/" target="_blank" rel="noopener">Method Swizzling</a></li>
<li><a href="http://stackoverflow.com/questions/5371601/how-do-i-implement-method-swizzling" target="_blank" rel="noopener">How do I implement method swizzling?</a></li>
<li><a href="http://stackoverflow.com/questions/5339276/what-are-the-dangers-of-method-swizzling-in-objective-c" target="_blank" rel="noopener">What are the Dangers of Method Swizzling in Objective C?</a></li>
<li><a href="https://github.com/rentzsch/jrswizzle" target="_blank" rel="noopener">JRSwizzle</a></li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>我们之所以让自己的类继承 <code>NSObject</code> 不仅仅因为苹果帮我们完成了复杂的内存分配问题，更是因为这使得我们能够用上 Runtime 系统带来的便利。深入理解 Runtime 系统的细节更有利于我们利用消息机制写出功能更强大的代码，比如 <code>Method Swizzling</code> 等。</p>
<p>参考链接</p>
<ul>
<li>原文：<a href="http://yulingtianxia.com/blog/2014/11/05/objective-c-runtime/" target="_blank" rel="noopener">Objective-C Runtime</a></li>
<li>Apple官方文档：<a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40008048" target="_blank" rel="noopener">Objective-C Runtime Programming Guide</a></li>
<li>Apple开源代码：<a href="https://opensource.apple.com/source/objc4/" target="_blank" rel="noopener">Objective-C Runtime源码</a></li>
<li><a href="http://blog.csdn.net/wzzvictory/article/details/8615569" target="_blank" rel="noopener">Objective-C runtime之运行时的基本特点</a></li>
<li><a href="http://cocoasamurai.blogspot.jp/2010/01/understanding-objective-c-runtime.html" target="_blank" rel="noopener">Understanding the Objective-C Runtime</a></li>
</ul>

            </div>
            <hr>

            
            <style>
    #reward {
        margin: 40px 0;
        text-align: center;
    }

    #reward .reward-link {
        font-size: 1.88rem;
    }

    #reward .btn-floating:hover {
        box-shadow: 0 6px 12px rgba(0, 0, 0, 0.2), 0 5px 15px rgba(0, 0, 0, 0.2);
    }

    #rewardModal {
        width: 320px;
        height: 350px;
    }

    #rewardModal .reward-title {
        margin: 15px auto;
        padding-bottom: 5px;
    }

    #rewardModal .modal-content {
        padding: 10px;
    }

    #rewardModal .close {
        position: absolute;
        right: 15px;
        top: 15px;
        color: rgba(0, 0, 0, 0.5);
        font-size: 1.3rem;
        line-height: 20px;
        cursor: pointer;
    }

    #rewardModal .close:hover {
        color: #ef5350;
        transform: scale(1.3);
        -moz-transform:scale(1.3);
        -webkit-transform:scale(1.3);
        -o-transform:scale(1.3);
    }

    #rewardModal .reward-tabs {
        margin: 0 auto;
        width: 210px;
    }

    .reward-tabs .tabs {
        height: 38px;
        margin: 10px auto;
        padding-left: 0;
    }

    .reward-content ul {
        padding-left: 0 !important;
    }

    .reward-tabs .tabs .tab {
        height: 38px;
        line-height: 38px;
    }

    .reward-tabs .tab a {
        color: #fff;
        background-color: #ccc;
    }

    .reward-tabs .tab a:hover {
        background-color: #ccc;
        color: #fff;
    }

    .reward-tabs .wechat-tab .active {
        color: #fff !important;
        background-color: #22AB38 !important;
    }

    .reward-tabs .alipay-tab .active {
        color: #fff !important;
        background-color: #019FE8 !important;
    }

    .reward-tabs .reward-img {
        width: 210px;
        height: 210px;
    }
</style>

<div id="reward">
    <a href="#rewardModal" class="reward-link modal-trigger btn-floating btn-large waves-effect waves-light red">赏</a>

    <!-- Modal Structure -->
    <div id="rewardModal" class="modal">
        <div class="modal-content">
            <a class="close modal-close"><i class="fa fa-close"></i></a>
            <h4 class="reward-title">支援小编点噻  $_$！！！</h4>
            <div class="reward-content">
                <div class="reward-tabs">
                    <ul class="tabs row">
                        <li class="tab col s6 alipay-tab waves-effect waves-light"><a href="#alipay">支付宝</a></li>
                        <li class="tab col s6 wechat-tab waves-effect waves-light"><a href="#wechat">微 信</a></li>
                    </ul>
                    <div id="alipay">
                        <img src="/medias/reward/alipay.jpg" class="reward-img" alt="支付宝打赏二维码">
                    </div>
                    <div id="wechat">
                        <img src="/medias/reward/wechat.png" class="reward-img" alt="微信打赏二维码">
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
    $(function () {
        $('.tabs').tabs();
    });
</script>
            

            <link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css">

<div id="article-share">
    
    <div class="social-share" data-disabled="qzone" data-wechat-qrcode-helper="<p>微信里点“发现”->“扫一扫”二维码便可查看分享。</p>"></div>
    
</div>

<script src="/libs/share/js/social-share.min.js"></script>

            <div class="reprint">
                <p>
                    <span class="reprint-tip">
                        <i class="fa fa-exclamation-circle"></i>&nbsp;&nbsp;转载请注明:
                    </span>
                    <a href="http://yoursite.com" class="b-link-green">张成的博客</a>
                    <i class="fa fa-angle-right fa-lg fa-fw text-color"></i>
                    <a href="/2019/03/24/20162017/2016-11-10-objective-c-runtime-xiang-jie/" class="b-link-green"></a>
                </p>
            </div>
        </div>
    </div>

    

    

    

    

    
        <style>
    .valine-card {
        margin: 1.5rem auto;
    }

    .valine-card .card-content {
        padding: 20px 20px 5px 20px;
    }

    #vcomments input[type=text],
    #vcomments input[type=email],
    #vcomments input[type=url],
    #vcomments textarea {
        box-sizing: border-box;
    }

    #vcomments p {
        margin: 2px 2px 10px;
        font-size: 1.05rem;
        line-height: 1.78rem;
    }

    #vcomments blockquote p {
        text-indent: 0.2rem;
    }

    #vcomments a {
        padding: 0 2px;
        color: #42b983;
        font-weight: 500;
        text-decoration: underline;
    }

    #vcomments img {
        max-width: 100%;
        height: auto;
        cursor: pointer;
    }

    #vcomments ol li {
        list-style-type: decimal;
    }

    #vcomments ol,
    ul {
        display: block;
        padding-left: 2em;
        word-spacing: 0.05rem;
    }

    #vcomments ul li,
    ol li {
        display: list-item;
        line-height: 1.8rem;
        font-size: 1rem;
    }

    #vcomments ul li {
        list-style-type: disc;
    }

    #vcomments ul ul li {
        list-style-type: circle;
    }

    #vcomments table, th, td {
        padding: 12px 13px;
        border: 1px solid #dfe2e5;
    }

    #vcomments table, th, td {
        border: 0;
    }

    table tr:nth-child(2n), thead {
        background-color: #fafafa;
    }

    #vcomments table th {
        background-color: #f2f2f2;
        min-width: 80px;
    }

    #vcomments table td {
        min-width: 80px;
    }

    #vcomments h1 {
        font-size: 1.85rem;
        font-weight: bold;
        line-height: 2.2rem;
    }

    #vcomments h2 {
        font-size: 1.65rem;
        font-weight: bold;
        line-height: 1.9rem;
    }

    #vcomments h3 {
        font-size: 1.45rem;
        font-weight: bold;
        line-height: 1.7rem;
    }

    #vcomments h4 {
        font-size: 1.25rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    #vcomments h5 {
        font-size: 1.1rem;
        font-weight: bold;
        line-height: 1.4rem;
    }

    #vcomments h6 {
        font-size: 1rem;
        line-height: 1.3rem;
    }

    #vcomments p {
        font-size: 1rem;
        line-height: 1.5rem;
    }

    #vcomments hr {
        margin: 12px 0;
        border: 0;
        border-top: 1px solid #ccc;
    }

    #vcomments blockquote {
        margin: 15px 0;
        border-left: 5px solid #42b983;
        padding: 1rem 0.8rem 0.3rem 0.8rem;
        color: #666;
        background-color: rgba(66, 185, 131, .1);
    }

    #vcomments pre {
        font-family: monospace, monospace;
        padding: 1.2em;
        margin: .5em 0;
        background: #272822;
        overflow: auto;
        border-radius: 0.3em;
        tab-size: 4;
    }

    #vcomments code {
        font-family: monospace, monospace;
        padding: 1px 3px;
        font-size: 0.92rem;
        color: #e96900;
        background-color: #f8f8f8;
        border-radius: 2px;
    }

    #vcomments pre code {
        font-family: monospace, monospace;
        padding: 0;
        color: #e8eaf6;
        background-color: #272822;
    }

    #vcomments pre[class*="language-"] {
        padding: 1.2em;
        margin: .5em 0;
    }

    #vcomments code[class*="language-"],
    pre[class*="language-"] {
        color: #e8eaf6;
    }

    #vcomments [type="checkbox"]:not(:checked), [type="checkbox"]:checked {
        position: inherit;
        margin-left: -1.3rem;
        margin-right: 0.4rem;
        margin-top: -1px;
        vertical-align: middle;
        left: unset;
        visibility: visible;
    }

    #vcomments b,
    strong {
        font-weight: bold;
    }

    #vcomments dfn {
        font-style: italic;
    }

    #vcomments small {
        font-size: 85%;
    }

    #vcomments cite {
        font-style: normal;
    }

    #vcomments mark {
        background-color: #fcf8e3;
        padding: .2em;
    }

    #vcomments table, th, td {
        padding: 12px 13px;
        border: 1px solid #dfe2e5;
    }

    table tr:nth-child(2n), thead {
        background-color: #fafafa;
    }

    #vcomments table th {
        background-color: #f2f2f2;
        min-width: 80px;
    }

    #vcomments table td {
        min-width: 80px;
    }

    #vcomments [type="checkbox"]:not(:checked), [type="checkbox"]:checked {
        position: inherit;
        margin-left: -1.3rem;
        margin-right: 0.4rem;
        margin-top: -1px;
        vertical-align: middle;
        left: unset;
        visibility: visible;
    }
</style>

<div class="card valine-card" data-aos="fade-up">
    <div id="vcomments" class="card-content"></div>
</div>

<script src="/libs/valine/av-min.js"></script>
<script src="/libs/valine/Valine.min.js"></script>
<script>
    new Valine({
        el: '#vcomments',
        appId: 'FoAoUvphmpdeetPbpxip1NYf-gzGzoHsz',
        appKey: '4Y0wsTcEcIoUjAJhUQFqJnyz',
        notify: 'true' === 'true',
        verify: 'true' === 'true',
        visitor: 'true' === 'true',
        avatar: 'mm',
        pageSize: '10',
        lang: 'zh-cn',
        placeholder: '说点什么吧'
    });
</script>
    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="fa fa-chevron-left"></i>&nbsp;上一篇</div>
            <div class="card">
                <a href="/2019/03/24/qian-duan/javascript/0-javascript-jian-jie/0.1-javascript-jian-shi/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/0.jpg" class="responsive-img" alt>
                        
                        <span class="card-title"></span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary">JavaScript简史JavaScript 诞生于 1995 年，由当时任职于 Netscape 公司的 布兰登·艾奇（Brendan Eich） 开发。第一个版本搭载于1995年2月发布的 Netscape Navigator 2.0浏</div>
                    <div class="publish-info">
                        <span class="publish-date">
                            <i class="fa fa-clock-o fa-fw icon-date"></i>2019-03-24
                        </span>
                        <span class="publish-author">
                            
                            <i class="fa fa-user fa-fw"></i>
                            Zhangcheng
                            
                        </span>
                    </div>
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                下一篇&nbsp;<i class="fa fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/2019/03/21/qian-duan/html/html-lie-biao/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/12.jpg" class="responsive-img" alt="HTML 速查列表">
                        
                        <span class="card-title">HTML 速查列表</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary">HTML 速查列表https://www.lanzous.com/i3lo13c密码:990126
HTML 基本文档  &lt;!DOCTYPE html&gt;
  &lt;html&gt;
  &lt;head&gt;
  &lt;t</div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="fa fa-clock-o fa-fw icon-date"></i>2019-03-21
                            </span>
                        <span class="publish-author">
                            
                            <i class="fa fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/html/" class="post-category" target="_blank">
                                    html
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/html/" target="_blank">
                        <span class="chip bg-color">html</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
    </div>
</article>
</div>


<script>
    $('#articleContent').on('copy', function (e) {
        // IE8 or earlier browser is 'undefined'
        if (typeof window.getSelection === 'undefined') return;

        var selection = window.getSelection();
        // if the selection is short let's not annoy our users.
        if (('' + selection).length < Number.parseInt('120')) {
            return;
        }

        // create a div outside of the visible area and fill it with the selected text.
        var bodyElement = document.getElementsByTagName('body')[0];
        var newdiv = document.createElement('div');
        newdiv.style.position = 'absolute';
        newdiv.style.left = '-99999px';
        bodyElement.appendChild(newdiv);
        newdiv.appendChild(selection.getRangeAt(0).cloneContents());

        // we need a <pre> tag workaround.
        // otherwise the text inside "pre" loses all the line breaks!
        if (selection.getRangeAt(0).commonAncestorContainer.nodeName === 'PRE') {
            newdiv.innerHTML = "<pre>" + newdiv.innerHTML + "</pre>";
        }

        var url = document.location.href;
        newdiv.innerHTML += '<br />'
            + '来源: 张成的博客<br />'
            + '作者: Zhangcheng<br />'
            + '链接: <a href="' + url + '">' + url + '</a><br />'
            + '本文章著作权归作者所有，任何形式的转载都请注明出处。';

        selection.selectAllChildren(newdiv);
        window.setTimeout(function () {bodyElement.removeChild(newdiv);}, 200);
    });
</script>

    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget">
            <div class="toc-title"><i class="fa fa-list-alt"></i>&nbsp;&nbsp;目录</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fa fa-list"></i>
    </a>
</div>


<script src="/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            // headingsOffset: -205,
            headingSelector: 'h2, h3, h4'
        });

        // modify the toc link href to support Chinese.
        let i = 0;
        let tocHeading = 'toc-heading-';
        $('#toc-content a').each(function () {
            $(this).attr('href', '#' + tocHeading + (++i));
        });

        // modify the heading title id to support Chinese.
        i = 0;
        $('#articleContent').children('h2, h3, h4').each(function () {
            $(this).attr('id', tocHeading + (++i));
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).slideUp(500);
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).slideDown(500);
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>
    

</main>


<footer class="page-footer bg-color">
    <div class="container row center-align">
        <div class="col s12 m8 l8 copy-right">
            Copyright © 2019 zhangcheng All Rights Reserved.
            
                &nbsp;<i class="fa fa-area-chart"></i>&nbsp;站点总字数:&nbsp;
                <span class="white-color">291.6k</span>
            

            
			
                <br>
                
                <span id="busuanzi_container_site_pv">
                    <i class="fa fa-heart-o"></i>
                    本站总访问量 <span id="busuanzi_value_site_pv" class="white-color"></span>
                </span>
                
                
                <span id="busuanzi_container_site_uv">
                    <i class="fa fa-users"></i>
                    次,&nbsp;访客数 <span id="busuanzi_value_site_uv" class="white-color"></span> 人.
                </span>
                
            
        </div>
        <div class="col s12 m4 l4 social-link social-statis">

    <a href="https://weibo.com/u/6420410379?is_all=1" class="tooltipped" target="_blank" data-tooltip="我的微博" data-position="top" data-delay="50">
        <i class="fa fa-weibo"></i>
    </a>





    <a href="mailto:2508723631@qq.com" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50">
        <i class="fa fa-envelope-open"></i>
    </a>



    <a href="tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=2508723631" class="tooltipped" data-tooltip="QQ联系我: 2508723631" data-position="top" data-delay="50">
        <i class="fa fa-qq"></i>
    </a>



    <a href="/atom.xml" class="tooltipped" target="_blank" data-tooltip="RSS 订阅" data-position="top" data-delay="50">
        <i class="fa fa-rss"></i>
    </a>
    <!--
        Facebook: fa-facebook
        Twitter: fa-twitter
        Google-plus: fa-google-plus
        Linkedin: fa-linkedin
        Tumblr: fa-tumblr
        Medium: fa-medium
        Slack: fa-slack
        新浪微博: fa-weibo
        微信: fa-wechat
     -->
</div>
    </div>
</footer>

<div class="progress-bar"></div>


<!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fa fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字" class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script src="/js/search.js"></script>
<script type="text/javascript">
$(function () {
    searchFunc("/" + "search.xml", 'searchInput', 'searchResult');
});
</script>
<!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fa fa-angle-up"></i>

    </a>
</div>


<script src="/libs/materialize/materialize.min.js"></script>
<script src="/libs/masonry/masonry.pkgd.min.js"></script>
<script src="/libs/aos/aos.js"></script>
<script src="/libs/scrollprogress/scrollProgress.min.js"></script>
<script src="/libs/lightGallery/js/lightgallery-all.min.js"></script>
<script src="/js/matery.js"></script>

<!-- Global site tag (gtag.js) - Google Analytics -->



    <script src="/libs/others/clicklove.js"></script>


    <script async src="/libs/others/busuanzi.pure.mini.js"></script>


</body>
</html>